/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.commercesystems.klaviyo_java.models.components;


import com.commercesystems.klaviyo_java.utils.LazySingletonValue;
import com.commercesystems.klaviyo_java.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class MetricAggregateQueryResourceObjectAttributes {

    /**
     * The metric ID used in the aggregation.
     */
    @JsonProperty("metric_id")
    private String metricId;

    /**
     * Optional pagination cursor to iterate over large result sets
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("page_cursor")
    private Optional<String> pageCursor;

    /**
     * Measurement key, e.g. `unique`, `sum_value`, `count`
     */
    @JsonProperty("measurements")
    private List<MetricAggregateQueryResourceObjectMeasurements> measurements;

    /**
     * Aggregation interval, e.g. "hour", "day", "week", "month"
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("interval")
    private JsonNullable<? extends Interval> interval;

    /**
     * Alter the maximum number of returned rows in a single page of aggregation results
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("page_size")
    private JsonNullable<Long> pageSize;

    /**
     * Optional attribute(s) used for partitioning by the aggregation function
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("by")
    private JsonNullable<? extends List<By>> by;

    /**
     * Provide fields to limit the returned data
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("return_fields")
    private JsonNullable<? extends List<String>> returnFields;

    /**
     * List of filters, must include time range using ISO 8601 format (YYYY-MM-DDTHH:MM:SS.mmmmmm).
     *             These filters follow a similar format to those in `GET` requests, the primary difference is that this endpoint asks for a list.
     *             The time range can be filtered by providing a `greater-or-equal` and a `less-than` filter on the `datetime` field.
     */
    @JsonProperty("filter")
    private List<String> filter;

    /**
     * The timezone used for processing the query, e.g. `'America/New_York'`.
     *             This field is validated against a list of common timezones from the [IANA Time Zone Database](https://www.iana.org/time-zones).
     *             While most are supported, a few notable exceptions are `Factory`, `Europe/Kyiv` and `Pacific/Kanton`. This field is case-sensitive.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timezone")
    private JsonNullable<String> timezone;

    /**
     * Provide a sort key (e.g. -$message)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sort")
    private Optional<? extends Sort> sort;

    @JsonCreator
    public MetricAggregateQueryResourceObjectAttributes(
            @JsonProperty("metric_id") String metricId,
            @JsonProperty("page_cursor") Optional<String> pageCursor,
            @JsonProperty("measurements") List<MetricAggregateQueryResourceObjectMeasurements> measurements,
            @JsonProperty("interval") JsonNullable<? extends Interval> interval,
            @JsonProperty("page_size") JsonNullable<Long> pageSize,
            @JsonProperty("by") JsonNullable<? extends List<By>> by,
            @JsonProperty("return_fields") JsonNullable<? extends List<String>> returnFields,
            @JsonProperty("filter") List<String> filter,
            @JsonProperty("timezone") JsonNullable<String> timezone,
            @JsonProperty("sort") Optional<? extends Sort> sort) {
        Utils.checkNotNull(metricId, "metricId");
        Utils.checkNotNull(pageCursor, "pageCursor");
        Utils.checkNotNull(measurements, "measurements");
        Utils.checkNotNull(interval, "interval");
        Utils.checkNotNull(pageSize, "pageSize");
        Utils.checkNotNull(by, "by");
        Utils.checkNotNull(returnFields, "returnFields");
        Utils.checkNotNull(filter, "filter");
        Utils.checkNotNull(timezone, "timezone");
        Utils.checkNotNull(sort, "sort");
        this.metricId = metricId;
        this.pageCursor = pageCursor;
        this.measurements = measurements;
        this.interval = interval;
        this.pageSize = pageSize;
        this.by = by;
        this.returnFields = returnFields;
        this.filter = filter;
        this.timezone = timezone;
        this.sort = sort;
    }
    
    public MetricAggregateQueryResourceObjectAttributes(
            String metricId,
            List<MetricAggregateQueryResourceObjectMeasurements> measurements,
            List<String> filter) {
        this(metricId, Optional.empty(), measurements, JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), filter, JsonNullable.undefined(), Optional.empty());
    }

    /**
     * The metric ID used in the aggregation.
     */
    @JsonIgnore
    public String metricId() {
        return metricId;
    }

    /**
     * Optional pagination cursor to iterate over large result sets
     */
    @JsonIgnore
    public Optional<String> pageCursor() {
        return pageCursor;
    }

    /**
     * Measurement key, e.g. `unique`, `sum_value`, `count`
     */
    @JsonIgnore
    public List<MetricAggregateQueryResourceObjectMeasurements> measurements() {
        return measurements;
    }

    /**
     * Aggregation interval, e.g. "hour", "day", "week", "month"
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Interval> interval() {
        return (JsonNullable<Interval>) interval;
    }

    /**
     * Alter the maximum number of returned rows in a single page of aggregation results
     */
    @JsonIgnore
    public JsonNullable<Long> pageSize() {
        return pageSize;
    }

    /**
     * Optional attribute(s) used for partitioning by the aggregation function
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<By>> by() {
        return (JsonNullable<List<By>>) by;
    }

    /**
     * Provide fields to limit the returned data
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<String>> returnFields() {
        return (JsonNullable<List<String>>) returnFields;
    }

    /**
     * List of filters, must include time range using ISO 8601 format (YYYY-MM-DDTHH:MM:SS.mmmmmm).
     *             These filters follow a similar format to those in `GET` requests, the primary difference is that this endpoint asks for a list.
     *             The time range can be filtered by providing a `greater-or-equal` and a `less-than` filter on the `datetime` field.
     */
    @JsonIgnore
    public List<String> filter() {
        return filter;
    }

    /**
     * The timezone used for processing the query, e.g. `'America/New_York'`.
     *             This field is validated against a list of common timezones from the [IANA Time Zone Database](https://www.iana.org/time-zones).
     *             While most are supported, a few notable exceptions are `Factory`, `Europe/Kyiv` and `Pacific/Kanton`. This field is case-sensitive.
     */
    @JsonIgnore
    public JsonNullable<String> timezone() {
        return timezone;
    }

    /**
     * Provide a sort key (e.g. -$message)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Sort> sort() {
        return (Optional<Sort>) sort;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The metric ID used in the aggregation.
     */
    public MetricAggregateQueryResourceObjectAttributes withMetricId(String metricId) {
        Utils.checkNotNull(metricId, "metricId");
        this.metricId = metricId;
        return this;
    }

    /**
     * Optional pagination cursor to iterate over large result sets
     */
    public MetricAggregateQueryResourceObjectAttributes withPageCursor(String pageCursor) {
        Utils.checkNotNull(pageCursor, "pageCursor");
        this.pageCursor = Optional.ofNullable(pageCursor);
        return this;
    }

    /**
     * Optional pagination cursor to iterate over large result sets
     */
    public MetricAggregateQueryResourceObjectAttributes withPageCursor(Optional<String> pageCursor) {
        Utils.checkNotNull(pageCursor, "pageCursor");
        this.pageCursor = pageCursor;
        return this;
    }

    /**
     * Measurement key, e.g. `unique`, `sum_value`, `count`
     */
    public MetricAggregateQueryResourceObjectAttributes withMeasurements(List<MetricAggregateQueryResourceObjectMeasurements> measurements) {
        Utils.checkNotNull(measurements, "measurements");
        this.measurements = measurements;
        return this;
    }

    /**
     * Aggregation interval, e.g. "hour", "day", "week", "month"
     */
    public MetricAggregateQueryResourceObjectAttributes withInterval(Interval interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = JsonNullable.of(interval);
        return this;
    }

    /**
     * Aggregation interval, e.g. "hour", "day", "week", "month"
     */
    public MetricAggregateQueryResourceObjectAttributes withInterval(JsonNullable<? extends Interval> interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = interval;
        return this;
    }

    /**
     * Alter the maximum number of returned rows in a single page of aggregation results
     */
    public MetricAggregateQueryResourceObjectAttributes withPageSize(long pageSize) {
        Utils.checkNotNull(pageSize, "pageSize");
        this.pageSize = JsonNullable.of(pageSize);
        return this;
    }

    /**
     * Alter the maximum number of returned rows in a single page of aggregation results
     */
    public MetricAggregateQueryResourceObjectAttributes withPageSize(JsonNullable<Long> pageSize) {
        Utils.checkNotNull(pageSize, "pageSize");
        this.pageSize = pageSize;
        return this;
    }

    /**
     * Optional attribute(s) used for partitioning by the aggregation function
     */
    public MetricAggregateQueryResourceObjectAttributes withBy(List<By> by) {
        Utils.checkNotNull(by, "by");
        this.by = JsonNullable.of(by);
        return this;
    }

    /**
     * Optional attribute(s) used for partitioning by the aggregation function
     */
    public MetricAggregateQueryResourceObjectAttributes withBy(JsonNullable<? extends List<By>> by) {
        Utils.checkNotNull(by, "by");
        this.by = by;
        return this;
    }

    /**
     * Provide fields to limit the returned data
     */
    public MetricAggregateQueryResourceObjectAttributes withReturnFields(List<String> returnFields) {
        Utils.checkNotNull(returnFields, "returnFields");
        this.returnFields = JsonNullable.of(returnFields);
        return this;
    }

    /**
     * Provide fields to limit the returned data
     */
    public MetricAggregateQueryResourceObjectAttributes withReturnFields(JsonNullable<? extends List<String>> returnFields) {
        Utils.checkNotNull(returnFields, "returnFields");
        this.returnFields = returnFields;
        return this;
    }

    /**
     * List of filters, must include time range using ISO 8601 format (YYYY-MM-DDTHH:MM:SS.mmmmmm).
     *             These filters follow a similar format to those in `GET` requests, the primary difference is that this endpoint asks for a list.
     *             The time range can be filtered by providing a `greater-or-equal` and a `less-than` filter on the `datetime` field.
     */
    public MetricAggregateQueryResourceObjectAttributes withFilter(List<String> filter) {
        Utils.checkNotNull(filter, "filter");
        this.filter = filter;
        return this;
    }

    /**
     * The timezone used for processing the query, e.g. `'America/New_York'`.
     *             This field is validated against a list of common timezones from the [IANA Time Zone Database](https://www.iana.org/time-zones).
     *             While most are supported, a few notable exceptions are `Factory`, `Europe/Kyiv` and `Pacific/Kanton`. This field is case-sensitive.
     */
    public MetricAggregateQueryResourceObjectAttributes withTimezone(String timezone) {
        Utils.checkNotNull(timezone, "timezone");
        this.timezone = JsonNullable.of(timezone);
        return this;
    }

    /**
     * The timezone used for processing the query, e.g. `'America/New_York'`.
     *             This field is validated against a list of common timezones from the [IANA Time Zone Database](https://www.iana.org/time-zones).
     *             While most are supported, a few notable exceptions are `Factory`, `Europe/Kyiv` and `Pacific/Kanton`. This field is case-sensitive.
     */
    public MetricAggregateQueryResourceObjectAttributes withTimezone(JsonNullable<String> timezone) {
        Utils.checkNotNull(timezone, "timezone");
        this.timezone = timezone;
        return this;
    }

    /**
     * Provide a sort key (e.g. -$message)
     */
    public MetricAggregateQueryResourceObjectAttributes withSort(Sort sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = Optional.ofNullable(sort);
        return this;
    }

    /**
     * Provide a sort key (e.g. -$message)
     */
    public MetricAggregateQueryResourceObjectAttributes withSort(Optional<? extends Sort> sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = sort;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        MetricAggregateQueryResourceObjectAttributes other = (MetricAggregateQueryResourceObjectAttributes) o;
        return 
            Objects.deepEquals(this.metricId, other.metricId) &&
            Objects.deepEquals(this.pageCursor, other.pageCursor) &&
            Objects.deepEquals(this.measurements, other.measurements) &&
            Objects.deepEquals(this.interval, other.interval) &&
            Objects.deepEquals(this.pageSize, other.pageSize) &&
            Objects.deepEquals(this.by, other.by) &&
            Objects.deepEquals(this.returnFields, other.returnFields) &&
            Objects.deepEquals(this.filter, other.filter) &&
            Objects.deepEquals(this.timezone, other.timezone) &&
            Objects.deepEquals(this.sort, other.sort);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            metricId,
            pageCursor,
            measurements,
            interval,
            pageSize,
            by,
            returnFields,
            filter,
            timezone,
            sort);
    }
    
    @Override
    public String toString() {
        return Utils.toString(MetricAggregateQueryResourceObjectAttributes.class,
                "metricId", metricId,
                "pageCursor", pageCursor,
                "measurements", measurements,
                "interval", interval,
                "pageSize", pageSize,
                "by", by,
                "returnFields", returnFields,
                "filter", filter,
                "timezone", timezone,
                "sort", sort);
    }
    
    public final static class Builder {
 
        private String metricId;
 
        private Optional<String> pageCursor = Optional.empty();
 
        private List<MetricAggregateQueryResourceObjectMeasurements> measurements;
 
        private JsonNullable<? extends Interval> interval;
 
        private JsonNullable<Long> pageSize;
 
        private JsonNullable<? extends List<By>> by = JsonNullable.undefined();
 
        private JsonNullable<? extends List<String>> returnFields = JsonNullable.undefined();
 
        private List<String> filter;
 
        private JsonNullable<String> timezone;
 
        private Optional<? extends Sort> sort = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The metric ID used in the aggregation.
         */
        public Builder metricId(String metricId) {
            Utils.checkNotNull(metricId, "metricId");
            this.metricId = metricId;
            return this;
        }

        /**
         * Optional pagination cursor to iterate over large result sets
         */
        public Builder pageCursor(String pageCursor) {
            Utils.checkNotNull(pageCursor, "pageCursor");
            this.pageCursor = Optional.ofNullable(pageCursor);
            return this;
        }

        /**
         * Optional pagination cursor to iterate over large result sets
         */
        public Builder pageCursor(Optional<String> pageCursor) {
            Utils.checkNotNull(pageCursor, "pageCursor");
            this.pageCursor = pageCursor;
            return this;
        }

        /**
         * Measurement key, e.g. `unique`, `sum_value`, `count`
         */
        public Builder measurements(List<MetricAggregateQueryResourceObjectMeasurements> measurements) {
            Utils.checkNotNull(measurements, "measurements");
            this.measurements = measurements;
            return this;
        }

        /**
         * Aggregation interval, e.g. "hour", "day", "week", "month"
         */
        public Builder interval(Interval interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = JsonNullable.of(interval);
            return this;
        }

        /**
         * Aggregation interval, e.g. "hour", "day", "week", "month"
         */
        public Builder interval(JsonNullable<? extends Interval> interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = interval;
            return this;
        }

        /**
         * Alter the maximum number of returned rows in a single page of aggregation results
         */
        public Builder pageSize(long pageSize) {
            Utils.checkNotNull(pageSize, "pageSize");
            this.pageSize = JsonNullable.of(pageSize);
            return this;
        }

        /**
         * Alter the maximum number of returned rows in a single page of aggregation results
         */
        public Builder pageSize(JsonNullable<Long> pageSize) {
            Utils.checkNotNull(pageSize, "pageSize");
            this.pageSize = pageSize;
            return this;
        }

        /**
         * Optional attribute(s) used for partitioning by the aggregation function
         */
        public Builder by(List<By> by) {
            Utils.checkNotNull(by, "by");
            this.by = JsonNullable.of(by);
            return this;
        }

        /**
         * Optional attribute(s) used for partitioning by the aggregation function
         */
        public Builder by(JsonNullable<? extends List<By>> by) {
            Utils.checkNotNull(by, "by");
            this.by = by;
            return this;
        }

        /**
         * Provide fields to limit the returned data
         */
        public Builder returnFields(List<String> returnFields) {
            Utils.checkNotNull(returnFields, "returnFields");
            this.returnFields = JsonNullable.of(returnFields);
            return this;
        }

        /**
         * Provide fields to limit the returned data
         */
        public Builder returnFields(JsonNullable<? extends List<String>> returnFields) {
            Utils.checkNotNull(returnFields, "returnFields");
            this.returnFields = returnFields;
            return this;
        }

        /**
         * List of filters, must include time range using ISO 8601 format (YYYY-MM-DDTHH:MM:SS.mmmmmm).
         *             These filters follow a similar format to those in `GET` requests, the primary difference is that this endpoint asks for a list.
         *             The time range can be filtered by providing a `greater-or-equal` and a `less-than` filter on the `datetime` field.
         */
        public Builder filter(List<String> filter) {
            Utils.checkNotNull(filter, "filter");
            this.filter = filter;
            return this;
        }

        /**
         * The timezone used for processing the query, e.g. `'America/New_York'`.
         *             This field is validated against a list of common timezones from the [IANA Time Zone Database](https://www.iana.org/time-zones).
         *             While most are supported, a few notable exceptions are `Factory`, `Europe/Kyiv` and `Pacific/Kanton`. This field is case-sensitive.
         */
        public Builder timezone(String timezone) {
            Utils.checkNotNull(timezone, "timezone");
            this.timezone = JsonNullable.of(timezone);
            return this;
        }

        /**
         * The timezone used for processing the query, e.g. `'America/New_York'`.
         *             This field is validated against a list of common timezones from the [IANA Time Zone Database](https://www.iana.org/time-zones).
         *             While most are supported, a few notable exceptions are `Factory`, `Europe/Kyiv` and `Pacific/Kanton`. This field is case-sensitive.
         */
        public Builder timezone(JsonNullable<String> timezone) {
            Utils.checkNotNull(timezone, "timezone");
            this.timezone = timezone;
            return this;
        }

        /**
         * Provide a sort key (e.g. -$message)
         */
        public Builder sort(Sort sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = Optional.ofNullable(sort);
            return this;
        }

        /**
         * Provide a sort key (e.g. -$message)
         */
        public Builder sort(Optional<? extends Sort> sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = sort;
            return this;
        }
        
        public MetricAggregateQueryResourceObjectAttributes build() {
            if (interval == null) {
                interval = _SINGLETON_VALUE_Interval.value();
            }
            if (pageSize == null) {
                pageSize = _SINGLETON_VALUE_PageSize.value();
            }
            if (timezone == null) {
                timezone = _SINGLETON_VALUE_Timezone.value();
            }            return new MetricAggregateQueryResourceObjectAttributes(
                metricId,
                pageCursor,
                measurements,
                interval,
                pageSize,
                by,
                returnFields,
                filter,
                timezone,
                sort);
        }

        private static final LazySingletonValue<JsonNullable<? extends Interval>> _SINGLETON_VALUE_Interval =
                new LazySingletonValue<>(
                        "interval",
                        "\"day\"",
                        new TypeReference<JsonNullable<? extends Interval>>() {});

        private static final LazySingletonValue<JsonNullable<Long>> _SINGLETON_VALUE_PageSize =
                new LazySingletonValue<>(
                        "page_size",
                        "500",
                        new TypeReference<JsonNullable<Long>>() {});

        private static final LazySingletonValue<JsonNullable<String>> _SINGLETON_VALUE_Timezone =
                new LazySingletonValue<>(
                        "timezone",
                        "\"UTC\"",
                        new TypeReference<JsonNullable<String>>() {});
    }
}

